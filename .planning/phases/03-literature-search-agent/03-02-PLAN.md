---
phase: 03-literature-search-agent
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - agents/literature-search.md
  - commands/search.md
autonomous: true

must_haves:
  truths:
    - "User can run /math:search and it delegates to the literature-search agent"
    - "The literature-search agent reads PROBLEM.md for domain, tags, known results, and references to construct targeted search queries"
    - "The agent queries both arXiv and Semantic Scholar via WebFetch and verifies every candidate paper against the source API"
    - "Only verified papers enter the Confirmed References section of LITERATURE.md; unverifiable papers are flagged as Unconfirmed"
    - "The agent synthesizes connections between confirmed papers and the user's specific problem with confidence tier markers"
    - "After search, the agent calls the session-manager to write a LIT- journal entry recording the search"
  artifacts:
    - path: "agents/literature-search.md"
      provides: "Complete literature search agent with discovery, verification, synthesis, and journal integration"
      contains: "Phase A"
    - path: "commands/search.md"
      provides: "Active /math:search command that validates context and delegates to literature-search agent"
      contains: "literature-search"
  key_links:
    - from: "commands/search.md"
      to: "agents/literature-search.md"
      via: "Task tool delegation (same pattern as /math:problem -> math-intake)"
      pattern: "agents/literature-search"
    - from: "agents/literature-search.md"
      to: "protocols/literature-protocol.md"
      via: "agent references protocol for all rules, schemas, API details"
      pattern: "literature-protocol"
    - from: "agents/literature-search.md"
      to: "agents/session-manager.md"
      via: "agent calls session-manager to write LIT- journal entry after search"
      pattern: "session-manager"
    - from: "agents/literature-search.md"
      to: "templates/LITERATURE.md"
      via: "agent creates LITERATURE.md from template if it does not exist"
      pattern: "LITERATURE.md"
---

<objective>
Create the literature search agent and activate the /math:search command, delivering the core search-verify-synthesize functionality.

Purpose: This is the heart of Phase 3. The agent performs multi-source literature search (arXiv + Semantic Scholar), verification of every reference against source APIs, synthesis of connections to the user's problem, and writes results to LITERATURE.md. The command provides the user-facing entry point.

Output: `agents/literature-search.md` and updated `commands/search.md`
</objective>

<execution_context>
@/Users/matteo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matteo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-literature-search-agent/03-RESEARCH.md
@.planning/phases/03-literature-search-agent/03-01-SUMMARY.md

@protocols/literature-protocol.md
@protocols/confidence-tiers.md
@protocols/journal-protocol.md
@agents/math-intake.md
@agents/session-manager.md
@commands/problem.md
@templates/LITERATURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create literature search agent</name>
  <files>agents/literature-search.md</files>
  <action>
Create `agents/literature-search.md` -- the specialized agent that performs literature search, verification, and synthesis. This is the largest single artifact in Phase 3.

**Agent structure (follow the pattern of `agents/math-intake.md` and `agents/session-manager.md`):**

**Frontmatter:**
```yaml
---
name: literature-search
description: Searches arXiv and Semantic Scholar for mathematical literature, verifies references against source APIs, synthesizes connections to the user's problem, and writes results to LITERATURE.md.
tools:
  - Read
  - Write
  - WebFetch
  - Bash
  - Glob
  - Task
---
```

Note: `WebFetch` is the primary tool for API calls. `Bash` is needed for Semantic Scholar POST batch verification via curl. `Task` is needed to call the session-manager agent for journal entries.

**Role section:**
You are a literature search agent for the math research plugin. Your job is to find, verify, and synthesize mathematical literature relevant to the user's research problem. You search arXiv and Semantic Scholar, verify every reference against source APIs (no hallucinated citations), synthesize connections between papers and the user's problem, and write structured results to LITERATURE.md.

Be rigorous about verification. Mathematicians require precise, verifiable references. A fabricated citation is worse than a missing one. When in doubt, mark as unconfirmed.

**Context References section:**
Load these before any operation:
- `@protocols/literature-protocol.md` -- Complete workflow, schemas, API reference, anti-hallucination rules
- `@protocols/confidence-tiers.md` -- [V]/[S]/[~] markers for synthesis
- `@protocols/journal-protocol.md` -- Journal entry format for LIT- entries

**Context from Calling Command section:**
The `/math:search` command passes:
- Problem directory path: `.math/problems/{slug}/`
- Problem slug: `{slug}`
- User's optional search query (if provided as argument to /math:search)

**Process section (the core logic, broken into clear steps):**

**Step 1: Load Problem Context**
- Read `.math/problems/{slug}/PROBLEM.md` -- extract domain, subdomain, tags, problem statement, known results, references, output_type
- Read `.math/problems/{slug}/NOTATION.md` -- extract notation context for query construction
- Read `.math/problems/{slug}/LITERATURE.md` if it exists -- check existing results to avoid duplicates
- Read `.math/config.json` -- check for `semantic_scholar_api_key` field; also check `SEMANTIC_SCHOLAR_API_KEY` env var
- If LITERATURE.md does not exist, create it from `templates/LITERATURE.md`, filling in problem slug and title

**Step 2: Construct Search Queries**
- Use the literature protocol's query construction guidelines
- Generate 3-5 queries for arXiv:
  1. Domain category filter + key concept keywords from tags (e.g., `(cat:math.FA+OR+cat:math.CA)+AND+(all:banach+AND+all:operator)`)
  2. Title-focused query with primary mathematical terms (e.g., `ti:Neumann+AND+ti:series+AND+ti:convergence`)
  3. If known results mention specific theorems/authors, query by author or theorem name
  4. Broader category browse if initial queries are narrow
- Generate 2-3 queries for Semantic Scholar:
  1. Key concepts as space-separated terms with `fieldsOfStudy=Mathematics` filter
  2. Specific theorem or technique names if mentioned in known results
  3. Author-based if references section has specific authors
- If the user provided an explicit search query (argument to /math:search), incorporate it as the primary query and adjust others around it
- Strip LaTeX notation from all query terms -- use plain mathematical English
- Show the user the queries before executing: "I'll search with these queries: [list]. Proceed?"

**Step 3: Phase A -- Discovery (arXiv)**
- Execute arXiv queries via WebFetch
- For each query, use URL format: `http://export.arxiv.org/api/query?search_query={query}&start=0&max_results=10&sortBy=relevance`
- WebFetch prompt: "Extract all paper entries from this Atom XML feed. For each entry, return: title, all author names, published date (year only), arXiv ID (the numeric part from the <id> URL, e.g., '2301.12345'), abstract (from <summary>), primary category, and DOI if present in <arxiv:doi>. Format as a numbered list with clear field labels."
- Collect all unique candidates (deduplicate by arXiv ID)
- If WebFetch returns unexpected results (HTML instead of XML, error page), note the issue and try the next query. If all arXiv queries fail, report to user and continue with Semantic Scholar only.
- Respect rate limits: if making multiple arXiv calls, note that a 3-second delay between calls is recommended (WebFetch calls are naturally spaced by agent processing time)

**Step 4: Phase A -- Discovery (Semantic Scholar)**
- Execute Semantic Scholar queries via WebFetch
- For each query, use URL format: `https://api.semanticscholar.org/graph/v1/paper/search?query={terms}&fields=paperId,title,authors,year,abstract,externalIds,citationCount,fieldsOfStudy,url&limit=10&fieldsOfStudy=Mathematics`
- If API key is available, include header note (WebFetch may not support custom headers -- if so, use Bash + curl with `-H "x-api-key: {key}"`)
- WebFetch prompt: "Parse this JSON response. For each paper in the 'data' array, extract: paperId, title, all author names, year, abstract, externalIds (arXiv ID and DOI if present), citationCount, and fieldsOfStudy. Format as a numbered list with clear field labels."
- Collect all unique candidates (deduplicate by paperId or DOI)
- If WebFetch returns errors or rate limit responses, note and continue with available results

**Step 5: Merge and Deduplicate Candidates**
- Merge arXiv and Semantic Scholar candidates into one list
- Deduplicate across sources: match by arXiv ID, DOI, or title+authors+year
- For duplicates found in both sources, note "Source: Both" and keep the richer metadata

**Step 6: Phase B -- Verification**
- For each candidate paper, verify against the source API:
  - **arXiv papers:** Batch verify using `http://export.arxiv.org/api/query?id_list={id1},{id2},{id3}` -- one call for up to 2000 IDs
  - **Semantic Scholar papers (no arXiv ID):** Individual lookup via `https://api.semanticscholar.org/graph/v1/paper/DOI:{doi}?fields=paperId,title,authors,year,abstract,externalIds` or use Bash + curl for batch POST if more than 10 papers
- For each verification response:
  - Compare title (fuzzy match -- minor formatting differences OK)
  - Compare authors (at least first author matches)
  - Compare year (exact or +/- 1 year for preprint-to-publication delays)
  - If match: mark CONFIRMED with verification timestamp and API URL used
  - If mismatch or fetch fails: mark UNCONFIRMED with reason (e.g., "arXiv ID not found", "metadata mismatch", "API error")
- Report verification results to user: "Verified {N} of {M} candidates. {K} could not be verified."

**Step 7: Phase C -- Synthesis**
- For each confirmed paper, analyze how it connects to the user's problem (read from PROBLEM.md):
  - Does it contain a theorem directly applicable to the problem?
  - Does it use a technique or approach relevant to the problem type?
  - Does it address the same mathematical objects or structures?
  - Does it provide counterexamples or negative results relevant to the problem?
- Structure the synthesis as defined in the protocol:
  - **Applicable Theorems:** [V] marker for direct theorem applicability
  - **Technique Connections:** [S] marker for agent-derived technique connections
  - **Gaps in Literature:** What aspects of the problem are NOT covered by found papers
  - **Suggested Reading Order:** Ordered list from most directly relevant to tangentially related
- Use confidence tier markers consistently: [V] for verified theorem connections, [S] for reasoned connections, [~] for speculative connections
- Do NOT just summarize abstracts -- connect each paper to the user's SPECIFIC problem

**Step 8: Write LITERATURE.md**
- Read existing LITERATURE.md (or use freshly created one)
- Add a new row to the Search History table with: date, query summary, arXiv result count, S2 result count, new confirmed count
- Add confirmed papers to the Confirmed References section using the protocol's entry format (REF-NNN prefix, continuing from last entry number)
- Replace or update the Synthesis section with the new synthesis (keeping any prior synthesis content if doing an incremental search)
- Add unconfirmed papers to the Unconfirmed References section
- Update frontmatter: total_papers, confirmed_count, unconfirmed_count, last_search, sources_queried
- Write the updated file back to disk

**Step 9: Journal Entry**
- Call the session-manager agent (via Task tool) with a LIT- journal entry:
  - category: LIT
  - title: descriptive title reflecting the search focus
  - agent_name: literature-search
  - strategy_type: `broad-survey` for initial/general search, `targeted-search` for follow-up/specific
  - tags: 3-5 mathematical concept tags from the search
  - what_tried: "Searched arXiv ({categories}) and Semantic Scholar (Mathematics) for: {query terms}. {N} candidates found, {M} confirmed, {K} unconfirmed."
  - outcome: SUCCEEDED (if confirmed > 0), PARTIAL (if some results but high unconfirmed), FAILED (if no results)
  - reasoning: why this outcome
  - artifacts: "LITERATURE.md updated with {N} new confirmed references"
  - related_files: "[LITERATURE.md](LITERATURE.md)"
  - insight: what was learned about the literature landscape

**Step 10: Report to User**
- Present a summary of results:
  - Number of papers found, confirmed, unconfirmed
  - Top 3-5 most relevant confirmed papers with brief relevance explanation
  - Key synthesis points (applicable theorems, technique connections)
  - Suggestions for follow-up searches if gaps exist
  - Note: "Full results saved in `.math/problems/{slug}/LITERATURE.md`"

**Error Handling section:**
- If PROBLEM.md does not exist or has status "draft": stop with "No defined problem found. Run `/math:problem` first."
- If WebFetch fails for an API: report the error, continue with the other API, note in results
- If both APIs fail: report to user, suggest trying again later, write a FAILED journal entry
- If all candidates are unconfirmed: report honestly, write results with all in unconfirmed section, note in synthesis
- If LITERATURE.md write fails: report error, display results in terminal so user doesn't lose them

**Important Instructions section:**
- NEVER include a paper in Confirmed References without API verification -- this is the core rule
- NEVER fabricate metadata (title, authors, year, identifiers) -- only use data returned by the API
- If you recognize a paper from training data but cannot verify it via API, it goes in Unconfirmed References with a note
- Always show the user search queries before executing
- Always report verification results transparently
- For follow-up searches (LITERATURE.md already has content), continue REF numbering and complement existing results
  </action>
  <verify>
Read `agents/literature-search.md` and confirm:
1. Frontmatter includes all required tools (Read, Write, WebFetch, Bash, Glob, Task)
2. Role section establishes agent identity and verification-first mindset
3. Context References include literature-protocol.md, confidence-tiers.md, journal-protocol.md
4. All 10 process steps present (Load Context through Report to User)
5. Phase A (Discovery) covers both arXiv and Semantic Scholar with concrete WebFetch URL templates
6. Phase B (Verification) uses batch arXiv id_list and individual S2 lookups
7. Phase C (Synthesis) connects papers to user's problem with confidence tier markers
8. Anti-hallucination rules explicitly stated in Important Instructions
9. Journal integration via session-manager Task call in Step 9
10. Error handling covers API failures, empty results, and missing prerequisites
  </verify>
  <done>A complete literature search agent exists at `agents/literature-search.md` with 10-step process covering discovery (arXiv + Semantic Scholar), verification (batch + individual), synthesis (with confidence tiers), LITERATURE.md writing, and journal integration via session-manager.</done>
</task>

<task type="auto">
  <name>Task 2: Activate /math:search command</name>
  <files>commands/search.md</files>
  <action>
Replace the "coming soon" placeholder in `commands/search.md` with an active command that validates context and delegates to the literature-search agent.

**Follow the exact pattern of `commands/problem.md`:** thin command that resolves path, validates prerequisites, and spawns the agent via Task tool.

**New content for `commands/search.md`:**

Frontmatter:
```yaml
---
description: Search arXiv and Semantic Scholar for mathematical literature relevant to your problem
agent: literature-search
allowed-tools:
  - Read
  - Write
  - WebFetch
  - Bash
  - Glob
  - Task
---
```

**Heading:** `# /math:search -- Search Mathematical Literature`

**Description:** Search arXiv and Semantic Scholar for papers relevant to your mathematical problem. Results are verified against source APIs and synthesized with connections to your problem.

**Usage:**
- `/math:search` -- Run a broad literature search based on your problem definition
- `/math:search "Neumann series convergence"` -- Search with a specific query focus

**Path Resolution section** (same pattern as problem.md):
1. Read `.math/config.json`
2. Get `current_problem` slug
3. Resolve problem directory as `.math/problems/{current_problem}/`
4. Pass resolved directory path to the literature-search agent

**Process section:**

**Step 0: Resolve current problem**
Read `.math/config.json` and extract `current_problem`.
- If `current_problem` is empty or missing: Check for Phase 1 legacy layout. If legacy, inform user to run `/math:init`. If no files, tell user "No active problem. Run `/math:init` first." Stop.
- If `current_problem` is set: Resolve the problem directory. Proceed.

**Step 1: Validate project exists**
Check `.math/` and `.math/problems/{current_problem}/` exist.
- If `.math/` missing: "No math project found. Run `/math:init` first." Stop.
- If problem directory missing: "Problem directory not found for '{current_problem}'. Run `/math:init` or `/math:switch`." Stop.

**Step 2: Validate problem is defined**
Read `.math/problems/{current_problem}/PROBLEM.md` frontmatter.
- If PROBLEM.md does not exist: "No problem defined for '{current_problem}'. Run `/math:problem` first to define your problem." Stop.
- If `status` is `draft`: "Problem is still in draft. Complete the intake wizard with `/math:problem` before searching." Stop.

**Step 3: Spawn literature search agent**
Use the Task tool to spawn `agents/literature-search.md`.

Pass context:
- Problem directory path: `.math/problems/{current_problem}/`
- Problem slug: `{current_problem}`
- User's search query (if provided as argument), or empty string if no argument
- `@protocols/literature-protocol.md`
- `@protocols/confidence-tiers.md`
- `@protocols/journal-protocol.md`

The agent handles all search, verification, synthesis, and writing.

**References section:**
- `@agents/literature-search.md` -- Literature search agent
- `@protocols/literature-protocol.md` -- Search workflow and verification rules
- `.math/config.json` -- Project configuration with current_problem pointer
  </action>
  <verify>
Read `commands/search.md` and confirm:
1. Frontmatter has agent: literature-search and all required allowed-tools
2. Path resolution follows config.json -> current_problem -> problem directory pattern
3. Step 0 handles empty current_problem and legacy layout
4. Step 1 validates .math/ and problem directory exist
5. Step 2 validates PROBLEM.md exists and is not draft
6. Step 3 spawns literature-search agent via Task tool with correct context
7. "Coming soon" placeholder text is completely gone
  </verify>
  <done>The `/math:search` command is active at `commands/search.md`, following the established command pattern (path resolution, validation, agent delegation via Task tool), replacing the "coming soon" placeholder.</done>
</task>

</tasks>

<verification>
1. `agents/literature-search.md` exists with complete 10-step search-verify-synthesize workflow
2. `commands/search.md` is active (no "coming soon" text) and delegates to the agent
3. Agent references `protocols/literature-protocol.md` for all rules
4. Agent uses WebFetch for arXiv and Semantic Scholar API calls
5. Agent verifies every reference before marking as confirmed
6. Agent writes results to LITERATURE.md using the template/schema
7. Agent calls session-manager for LIT- journal entries
8. Command validates prerequisites (project exists, problem defined, not draft)
</verification>

<success_criteria>
- Running `/math:search` on a defined problem would: query arXiv + Semantic Scholar, verify results, synthesize connections, write LITERATURE.md, and log a journal entry
- No hallucinated references possible in Confirmed References section
- Search agent handles both fresh searches and incremental additions to existing LITERATURE.md
- Command follows established pattern (path resolution, validation, agent delegation)
</success_criteria>

<output>
After completion, create `.planning/phases/03-literature-search-agent/03-02-SUMMARY.md`
</output>
