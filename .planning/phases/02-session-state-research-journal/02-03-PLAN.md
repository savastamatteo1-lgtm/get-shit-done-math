---
phase: 02-session-state-research-journal
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - commands/resume.md
  - agents/session-manager.md
autonomous: true

must_haves:
  truths:
    - "/math:resume generates DASHBOARD.md by reading all problem artifacts and displays a structured session restoration summary with provenance tracking"
    - "Dashboard includes suggested next action that is context-specific based on current state and journal history"
    - "Session-management agent handles journal entry writing following journal-protocol.md and performs dead-end detection before proof attempts"
    - "Session-management agent checks for changed conditions when prior similar strategy is found and highlights opportunities for retry"
  artifacts:
    - path: "commands/resume.md"
      provides: "/math:resume command that generates and displays DASHBOARD.md"
      contains: "DASHBOARD.md"
    - path: "agents/session-manager.md"
      provides: "Session management agent with journal writing and dead-end detection"
      contains: "Dead-End Detection"
  key_links:
    - from: "commands/resume.md"
      to: "templates/DASHBOARD.md"
      via: "Resume command reads template and fills with artifact data"
      pattern: "DASHBOARD"
    - from: "agents/session-manager.md"
      to: "protocols/journal-protocol.md"
      via: "Agent loads journal protocol for entry format and detection rules"
      pattern: "journal-protocol"
    - from: "agents/session-manager.md"
      to: "templates/JOURNAL.md"
      via: "Agent writes entries into JOURNAL.md following template structure"
      pattern: "JOURNAL\\.md"
---

<objective>
Create the /math:resume command for session restoration and a session-management agent that handles journal writing and dead-end detection.

Purpose: This delivers the core Phase 2 capability -- the ability to leave a session and return with full context. /math:resume generates a dashboard from source artifacts. The session-management agent is the workhorse that all future agents delegate to for journal operations and strategy matching.
Output: 2 files -- resume command, session-management agent
</objective>

<execution_context>
@/Users/matteo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matteo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-session-state-research-journal/02-CONTEXT.md
@.planning/phases/02-session-state-research-journal/02-RESEARCH.md

# Plan 01 outputs (templates and protocol):
@.planning/phases/02-session-state-research-journal/02-01-SUMMARY.md
@templates/DASHBOARD.md
@templates/JOURNAL.md
@protocols/journal-protocol.md
@protocols/confidence-tiers.md

# Phase 1 command pattern to follow:
@commands/status.md
@commands/help.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /math:resume command for session restoration</name>
  <files>
    commands/resume.md
  </files>
  <action>
Create `commands/resume.md` following the Phase 1 command pattern (YAML frontmatter + markdown Process steps).

```yaml
---
description: Resume a math research session with full context restoration
allowed-tools:
  - Read
  - Write
  - Glob
  - Grep
---
```

**Step 1: Validate project**
Check `.math/config.json` exists. If not: "No math project found. Run `/math:init` first." Stop.

**Step 2: Resolve active problem**
Read `.math/config.json`. Get `current_problem` slug. If no `current_problem` (empty string or missing): "No active problem. Run `/math:init` to create one, or `/math:switch` to select an existing one." Stop.

Construct problem path: `.math/problems/{current_problem}/`
Verify the directory exists. If not (corrupted state): warn and suggest `/math:init`.

**Step 3: Read all artifacts**
Read each file in the problem directory, extracting key data. Handle missing files gracefully (future phases create LITERATURE.md, PROOF.md, COMPUTATION.md -- they won't exist yet).

Files to read:
1. **PROBLEM.md** -- Extract frontmatter (status, domain, type, output_type) and first 3-5 lines of the body after frontmatter (problem statement preview)
2. **STATE.md** -- Extract frontmatter (current_state, problem_defined, notation_configured, session_count)
3. **JOURNAL.md** -- Extract frontmatter (total_entries, last_entry, strategies_tried). From the body, find the most recent entry in the Proof Attempts section (last `### PROOF-*` heading) for "Last Approach Tried" section.
4. **NOTATION.md** -- Extract frontmatter (domain, based_on_preset, modified)
5. **LITERATURE.md** (if exists) -- Extract paper count, key findings. If file doesn't exist, show "No literature search yet"
6. **PROOF.md** (if exists) -- Extract step count, gap count, confidence tier counts. If doesn't exist, show "No proof attempted yet"
7. **COMPUTATION.md** (if exists) -- Extract computation count, key results. If doesn't exist, show "No computations yet"

**Step 4: Generate DASHBOARD.md**
Using the `templates/DASHBOARD.md` structure, fill all placeholders with extracted data:

- `{PROBLEM_TITLE}`: from PROBLEM.md frontmatter or first line of body
- `{CURRENT_STATE}`: from STATE.md frontmatter `current_state`
- `generated`: current ISO timestamp
- `problem`: current_problem slug
- `session_number`: increment STATE.md `session_count` by 1 (and update STATE.md)

Fill each section:

**Problem section:** First 3-5 lines of PROBLEM.md body. If problem not yet defined, show "Problem not yet submitted. Run /math:problem."

**Proof Progress subsection:**
- If PROOF.md exists: show strategy, steps completed/total, open gaps, confidence tier counts
- If no PROOF.md: "No proof attempted yet"
- Provenance: show agent name and timestamp from most recent proof journal entry

**Literature Found subsection:**
- If LITERATURE.md exists: show paper count, key theorem/finding
- If no LITERATURE.md: "No literature search yet"
- Provenance: from most recent LIT- journal entry

**Computations subsection:**
- If COMPUTATION.md exists: show computation count, key results
- If no COMPUTATION.md: "No computations yet"
- Provenance: from most recent COMP- journal entry

**Last Approach Tried subsection:**
- From JOURNAL.md: find the most recent proof entry
- Show: approach description, outcome (SUCCEEDED/FAILED/PARTIAL/etc.), journal entry ID
- If no journal entries: "No approaches tried yet"

**Suggested Next Action section:**
Generate a context-specific suggestion based on the current state. Use this decision tree:

1. If state is INITIALIZED and no problem defined: "Submit a problem with `/math:problem` to begin your research."
2. If problem defined but no literature searched (no LIT- entries in journal): "Consider starting with a literature search to find relevant existing results. `/math:search` (available Phase 3)"
3. If literature found but no proof attempted: "Literature has been reviewed. Consider starting proof development. `/math:prove` (available Phase 4)"
4. If proof in progress with gaps: Mention the specific gap from the last PROOF journal entry. "The proof has a gap at {description}. Consider {specific suggestion based on gap type}."
5. If proof in progress and last approach failed/abandoned: Suggest alternative strategy or revisiting with new information. Reference journal insights.
6. If proof complete: "Proof development appears complete. Consider generating LaTeX output. `/math:write` (available Phase 7)"
7. Default: "Review the current state and decide on next steps. Use `/math:help` to see available commands."

The suggestion should be **specific** and reference actual artifacts/findings when available, not generic. This is the user decision: "Dashboard ends with a suggested next action based on current state."

Write the filled DASHBOARD.md to `.math/problems/{current_problem}/DASHBOARD.md`.

**Step 5: Update STATE.md**
Increment `session_count` by 1 in STATE.md frontmatter. Add history entry: timestamp, "Session resumed", "Session #{N}".

**Step 6: Display dashboard**
Output the contents of the generated DASHBOARD.md to the user. The dashboard IS the session restoration -- the user reads it and knows exactly where they left off.

**Step 7: Update last_active**
Update the problem's `last_active` timestamp in `.math/config.json`.

## Error Handling

- Missing artifacts (LITERATURE.md, PROOF.md, COMPUTATION.md) are expected -- show "not yet" messages, don't error
- Corrupted JOURNAL.md frontmatter: warn and regenerate from body content if possible, or show "Journal needs repair"
- Empty problem directory: suggest `/math:init` to reinitialize

## References
- `@templates/DASHBOARD.md` -- Dashboard structure template
- `@protocols/journal-protocol.md` -- Journal entry format (for reading journal)
- `@protocols/confidence-tiers.md` -- Confidence tier markers (for dashboard display)
  </action>
  <verify>
Verify command file:
- `cat commands/resume.md` -- must have YAML frontmatter with description
- Grep for "DASHBOARD.md" -- must generate dashboard
- Grep for "Suggested Next Action" -- must include suggestion logic
- Grep for "session_count\|session_number" -- must track session count
- Grep for "provenance\|Source:" -- must include provenance tracking
- Grep for "LITERATURE.md\|PROOF.md\|COMPUTATION.md" -- must handle future artifact files
  </verify>
  <done>
/math:resume reads all problem artifacts, generates DASHBOARD.md with filled sections (problem preview, proof progress, literature, computations, last approach, suggested next action with provenance tracking), increments session count, displays dashboard to user. Handles missing future-phase artifacts gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session-management agent for journal writing and dead-end detection</name>
  <files>
    agents/session-manager.md
  </files>
  <action>
Create `agents/session-manager.md` following the Phase 1 agent pattern established in `agents/math-intake.md` -- an agent definition with role, tools, context references, and detailed process instructions.

**Agent Header:**
```yaml
---
name: session-manager
description: Manages research journal entries and performs dead-end detection. Called by other agents to record significant research actions and check for prior similar approaches.
tools:
  - Read
  - Write
  - Grep
---
```

**Role Section:**
This agent is the central journal manager for the math research plugin. It has two primary functions:
1. **Write journal entries** -- Called by other agents (proof, literature, computation) after significant actions to record what happened, what was learned, and update journal metadata.
2. **Dead-end detection** -- Called by the proof agent BEFORE attempting a new strategy to check if a similar approach was tried before and surface relevant prior attempts.

**Context References:**
```
@protocols/journal-protocol.md
@protocols/confidence-tiers.md
```

**Function 1: Write Journal Entry**

When called to write a journal entry, the agent receives:
- `category`: One of PROOF, LIT, COMP, NOTE
- `title`: Descriptive title for the entry
- `agent_name`: Which agent performed the action
- `strategy_type`: From the 14-type taxonomy (for PROOF entries)
- `tags`: Array of mathematical concept tags
- `what_tried`: Description of what was attempted
- `outcome`: One of SUCCEEDED, FAILED, PARTIAL, ABANDONED, IN_PROGRESS
- `reasoning`: Why this outcome occurred
- `artifacts`: Files created or modified
- `related_files`: Links to relevant artifacts
- `insight`: What was learned (REQUIRED)

Process:
1. Read JOURNAL.md from the active problem directory (resolve via `.math/config.json` → `current_problem` → `.math/problems/{slug}/JOURNAL.md`)
2. Parse frontmatter to get `total_entries` and `strategies_tried`
3. Determine next entry number for the category (count existing entries in that category section + 1, format as 3-digit padded: 001, 002, etc.)
4. Format the entry per journal-protocol.md entry template
5. Insert the entry at the end of the appropriate category section in the markdown body (before the next `## ` heading or at end of file)
6. Update frontmatter:
   - Increment `total_entries`
   - Set `last_entry` to current ISO timestamp
   - For PROOF entries: add/update entry in `strategies_tried` array with id, strategy, status (map outcome to status: SUCCEEDED→succeeded, FAILED/ABANDONED→abandoned, PARTIAL/IN_PROGRESS→in-progress), tags
7. Write updated JOURNAL.md back to disk

**Function 2: Dead-End Detection**

When called to check for prior similar strategies, the agent receives:
- `proposed_strategy_type`: The strategy type about to be attempted
- `proposed_tags`: Tags describing the proposed approach

Process (follows the dead-end detection protocol from `protocols/journal-protocol.md`):

1. Read JOURNAL.md frontmatter `strategies_tried` array
2. For each prior entry in `strategies_tried`:
   a. Check strategy type match: does `prior.strategy` equal `proposed_strategy_type`?
   b. Check tag overlap: count shared tags between `prior.tags` and `proposed_tags`. Flag if >= 2.
   c. If either match criterion met AND prior status is "abandoned" or "failed" (not "succeeded" or "in-progress"):
      → This is a potential dead-end match.
3. For each match:
   a. Read the full entry body from JOURNAL.md (find the entry by its ID heading)
   b. Check if conditions have changed since the prior attempt:
      - Read JOURNAL.md for entries with timestamps AFTER the matched entry's timestamp
      - Look for LIT- entries (new literature found?)
      - Look for PROOF- entries with status succeeded (new lemmas proved?)
      - Look for COMP- entries (new computation results?)
   c. Determine message type:

   **If conditions have changed:**
   Present to user:
   ```
   Previous attempt '{entry_title}' ({entry_id}) used {strategy_type}
   and was {outcome} because: {reasoning}.

   However, since then:
   {list of new developments with their journal entry IDs}

   This may address the original blocker. Worth retrying?
   ```

   **If conditions have NOT changed:**
   Present to user:
   ```
   Note: A similar approach was tried before — see {entry_id}.
   Strategy: {strategy_type}. Outcome: {outcome}.
   Insight: {insight}.

   Proceed with the new attempt anyway?
   ```

4. Wait for user response:
   - If user proceeds: return a signal to the calling agent to proceed, and note that a re-attempt journal entry should include `re_attempt_of: {prior_entry_id}` in its description
   - If user declines: return a signal to the calling agent to suggest an alternative strategy

5. If NO matches found: return a signal that no prior similar attempts exist, proceed normally.

**Function 3: Quick Note**

When called to add a quick user note (from a future /math:note command or directly):
- Category is always NOTE
- Strategy type can be omitted (not proof-related)
- Does NOT trigger dead-end detection
- Does NOT add to strategies_tried frontmatter
- Still requires insight/takeaway field

**Writing Guidelines (embedded in agent):**
Repeat the key guidelines from journal-protocol.md:
- Write at "significant action" granularity
- Use specific, descriptive titles
- 3-5 tags per entry using mathematical concepts
- Insight/Takeaway is NEVER optional
- Keep entries concise but complete

**Error Handling:**
- If JOURNAL.md doesn't exist in the problem directory: create it from template
- If frontmatter is malformed: attempt repair by re-parsing, warn user
- If entry number conflicts (duplicate): use next available number
  </action>
  <verify>
Verify agent file:
- `cat agents/session-manager.md` -- must have YAML frontmatter with name, description, tools
- Grep for "Dead-End Detection" -- must contain detection logic
- Grep for "journal-protocol.md" -- must reference the protocol
- Grep for "strategies_tried" -- must read and update frontmatter
- Grep for "conditions.*changed\|changed.*conditions" -- must check for changed conditions (opportunity highlighting per user decision)
- Grep for "Proceed.*anyway\|proceed anyway" -- must include gentle nudge message (not blocking)
- Grep for "Insight/Takeaway\|insight" -- must enforce required insight field
- Grep for "Write Journal Entry\|Function 1\|write.*entry" -- must have entry writing function
  </verify>
  <done>
Session-management agent provides 3 functions: (1) Write journal entries with proper formatting, frontmatter updates, and category placement; (2) Dead-end detection with strategy type + tag matching, condition change checking, gentle nudge messages for unchanged conditions, and opportunity highlighting for changed conditions; (3) Quick note for user observations. Agent loads journal-protocol.md and confidence-tiers.md via @-reference. Enforces required insight/takeaway field on all entries.
  </done>
</task>

</tasks>

<verification>
1. /math:resume generates DASHBOARD.md from source artifacts with all required sections (problem, state, proof progress, literature, computations, last approach, suggested next action)
2. Dashboard provenance tracking shows agent name and timestamp for each section
3. Dashboard suggested next action uses decision tree based on current state (not generic)
4. Session-management agent writes properly formatted journal entries per protocol
5. Dead-end detection checks strategy type AND tag overlap (2+) against prior FAILED/ABANDONED entries
6. When conditions have changed, agent highlights opportunities with specific new developments
7. When conditions unchanged, agent gives gentle nudge with prior insight and "Proceed anyway?" prompt
8. Both files follow established patterns from Phase 1 (command pattern, agent pattern)
</verification>

<success_criteria>
- User can run /math:resume and see a structured dashboard showing problem state, proof progress, literature, computations, last approach tried, and a specific suggested next action
- Each dashboard section shows provenance (which agent, when)
- Session-management agent can write journal entries and perform dead-end detection per the locked user decisions
- Dead-end detection is gentle (nudge, not block) and highlights opportunities from changed conditions
- Missing future-phase artifacts (LITERATURE.md, PROOF.md, COMPUTATION.md) are handled gracefully with "not yet" messages
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-state-research-journal/02-03-SUMMARY.md`
</output>
